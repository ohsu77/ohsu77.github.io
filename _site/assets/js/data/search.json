[
  
  {
    "title": "347. Top K Frequent Elements",
    "url": "/posts/347.-top-k-frequent-elements/",
    "categories": "programming, leetcode",
    "tags": "hash map, priority queue, heap, bucket sort",
    "date": "2024-07-30 21:08:48 -0400",
    





    
    "snippet": "url:https://leetcode.com/problems/top-k-frequent-elements/description/Example  Input: nums = [1,1,1,2,2,3], k = 2Output: [1,2]üíª CodeApproach : Count each number using hash, then prioritize for k nu...",
    "content": "url:https://leetcode.com/problems/top-k-frequent-elements/description/Example  Input: nums = [1,1,1,2,2,3], k = 2Output: [1,2]üíª CodeApproach : Count each number using hash, then prioritize for k number of elements.1. Brute force  Hash Map &amp; Priority Queue  TC : O(n log n)          n : hash map      log m : heap        SC: O(n)class Solution:    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:        freq = {}        for num in nums:            if num not in freq:                freq[num] = 1            else:                freq[num] += 1        heap = []        for num, count in freq.items():            heapq.heappush(heap, (count, num))  # store count first! (minHeap)            if len(heap) &gt; k:                heapq.heappop(heap)                res = [num for count, num in heap]        return resThis method is operated in 2 steps.   First, it counts with a hash map so that we know each element appeared how many times.   Second, a priority queue can be used by importing heapq. Since the minheap is a default implementation in Python, storing count first allows it to pop least frequent elements first when heapq is full; this only stores k number of most frequent elements.2. Optimised Solution  Hash Map &amp; Bucket Sort  TC : O(n)  SC: O(n)class Solution:    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:        res = []        freq = {}        # [[], [], [], [], [], []]        buckets = [[] for _ in range(len(nums))]                for num in nums:            if num not in freq:                freq[num] = 1            else:                freq[num] += 1        for num, cnt in freq.items():            # bucket starts from index 0, so cnt - 1            buckets[cnt - 1].append(num)                # iterate the bucket from the end (most frequent)        for i in range(len(buckets) - 1, -1, -1):            if buckets[i]:                for j in bucekts[i]:                    res.append(j)                    if len(res) == k:                        return resThe feature of the Bucket Sort is to store multiple elements at a single index by creating subarrays.We can simply iterate the bucket from the back until we have k number of elements.  Additional Material  Using extend(arr) helps to have more brief code.  # Learning how to use extend() function# it stores all elements inside the bracket (no bracket included)    for i in range(len(buckets) - 1, -1, -1):        if buckets[i]:            res.extend(buckets[i])            if len(res) &gt;= k:   # extend could store more than k                return res[:k]    extend(arr) basically stores all elements in a single bucekt."
  },
  
  {
    "title": "8. String to Integer (atoi)",
    "url": "/posts/8.-string-to-integer-(atoi)/",
    "categories": "programming, leetcode",
    "tags": "tag",
    "date": "2024-07-30 20:23:22 -0400",
    





    
    "snippet": "url: https://leetcode.com/problems/string-to-integer-atoi/description/Example  Input: s = ‚Äú1337c0d3‚ÄùOutput: 1337 Explanation:  Step 1: ‚Äú1337c0d3‚Äù (no characters read because there is no leading whi...",
    "content": "url: https://leetcode.com/problems/string-to-integer-atoi/description/Example  Input: s = ‚Äú1337c0d3‚ÄùOutput: 1337 Explanation:  Step 1: ‚Äú1337c0d3‚Äù (no characters read because there is no leading whitespace) Step 2: ‚Äú1337c0d3‚Äù (no characters read because there is neither a ‚Äò-‚Äò nor ‚Äò+‚Äô)Step 3: ‚Äú1337c0d3‚Äù (‚Äú1337‚Äù is read in; reading stops because the next character is a non-digit)üíª CodeApproach :  - Ignore every comming string elements.  - Make sure set the Max &amp; Min range. - check sign first, and integers.  TC : O(n)  SC: O(1)class Solution:    def myAtoi(self, s: str) -&gt; int:        max_int = 2**31 - 1        min_int = -2**31        i = 0   # current index        n = len(s)        # Step 1: Whitespace exists, then move current index        while i &lt; n and s[i] == ' ':            i += 1                # Step 2: recognizing positive (1) or negative (-1)        # Check the very first sign only!        sign = 1        if i &lt; n and (s[i] == '+' or s[i] == '-'):            if s[i] == '-':                sign = -1            i += 1        # Step 3: now we check integers only        result = 0        while i &lt; n and s[i].isdigit():            result = result * 10 + int(s[i])    # convert str -&gt; int            i += 1        result *= sign        # checking the range validation        if result &lt; min_int:            return min_int        if result &gt; max_int:            return max_int        return result"
  },
  
  {
    "title": "139. Word Break",
    "url": "/posts/139.-word-break/",
    "categories": "programming, leetcode",
    "tags": "dp, dfs",
    "date": "2024-07-30 14:58:50 -0400",
    





    
    "snippet": "url: https://leetcode.com/problems/word-break/description/Example  Input: s = ‚Äúleetcode‚Äù, wordDict = [‚Äúleet‚Äù,‚Äùcode‚Äù]Output: true Explanation: Return true because ‚Äúleetcode‚Äù can be segmented as ‚Äúlee...",
    "content": "url: https://leetcode.com/problems/word-break/description/Example  Input: s = ‚Äúleetcode‚Äù, wordDict = [‚Äúleet‚Äù,‚Äùcode‚Äù]Output: true Explanation: Return true because ‚Äúleetcode‚Äù can be segmented as ‚Äúleet code‚Äù.üí° Note that you are allowed to reuse a dictionary word.üíª CodeApproach : We only need to iterate s once, and wordDict should be checked at the same time.Things to be considered :  Strings in the wordDict can be used multiple times.  Unique strings.  Matching strings in s cannot be overlapped.1. Dynamic Programming  TC : O(n * m)          n : length of s      m : max length of wordDict        SC: O(n) - dpclass Solution:    def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:        # All the strings of wordDict are unique.        wordSet = set(wordDict)        # checking strings connected w/o overlapping        # true .... true -&gt; it makes a single string that in twordDict        dp = [False] * (len(s) + 1)        dp[0] = True         for i in range(1, len(s) + 1):            for j in range(i):                # dp[j] picks up where we left off last time                # until it matches                if dp[j] and s[j:i] in wordSet:                     dp[i] = True                    break                # return if the last index is true        return dp[len(s)]Using DP to track whether the current position of s is the part of the strings in wordDict allows an intuitive result because of the dp table. Check below the short version of dp table in processing:                      l      e      e      t      c      o      d      e        -------------------------------------------------------------------        dp = [True, False, False, False, False, False, False, False, False]        dp = [True, False, False, False, True, False, False, False, False]        dp = [True, False, False, False, True, False, False, False, True]            =&gt; dp[len(s)] = True            It checks only if the last index is True2. DFS  TC : O(n^2)  SC: O(n)    class Solution:  def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:      visited = {}      wordSet = set(wordDict)      def dfs(s, wordSet, visited):          if s in visited:              return visited[s]          if s in wordSet:              return True          for i in range(1, len(s)):              prefix = s[:i]              if prefix in wordSet and dfs(s[i:], wordSet, visited):                  visited[s] = True                  return True                  visited[s] = False          return False      return dfs(s, wordSet, visited)        The code processing:      Initial call: dfs(\"leetcode\")      Check prefix \"l\", not in wordSet.      Check prefix \"le\", not in wordSet.      Check prefix \"lee\", not in wordSet.      Check prefix \"leet\", in wordSet.          Recursive call: dfs(\"code\")              Check prefix \"c\", not in wordSet.              Check prefix \"co\", not in wordSet              Check prefix \"cod\", not in wordSet              Check prefix \"code\", in wordSet                  Memoize and return True for \"code\".          Memoize and return True for \"leetcode\"      "
  },
  
  {
    "title": "198. House Robber",
    "url": "/posts/198.-house-robber/",
    "categories": "programming, leetcode",
    "tags": "DP, Dynamic Programming, House Robber",
    "date": "2024-07-26 13:35:07 -0400",
    





    
    "snippet": "url: https://leetcode.com/problems/house-robber/description/Example  Input: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). ...",
    "content": "url: https://leetcode.com/problems/house-robber/description/Example  Input: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.üíª Code1. Brute Force (does not pass all cases)  TC : O(n)  SC: O(n) - stackclass Solution:    def rob(self, nums: List[int]) -&gt; int:        n = len(nums)           res = 0        odd_house = []        even_house = [nums[0]]        for i in range(1, n):            if i % 2 == 1:\t# odd houses                odd_house.append(nums[i])            else:                even_house.append(nums[i])                    res = max(sum(odd_house), sum(even_house))          return res My initial approach to the problem is checking houses to see whether they are odd or even.However, this method can‚Äôt handle edge cases. For example, there is a possibility that the sum of indices 0 and 3 can make a maximum amount.2. Dynamic Programming  TC : O(n)  SC: O(n) - DPclass Solution:    def rob(self, nums: List[int]) -&gt; int:        n = len(nums)        if n == 1:            return nums[0]        dp = [0] * n        dp[0] = nums[0]        dp[1] = max(nums[0], nums[1])        for i in range(2, n):            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])        return dp[-1]Using Dynamic Programming cut the edges where I had a problem. This compares with the current(i - 2) + current(i) and current(i - 1), and the current the maximum value is stored at the current position in dp.By changing the current value, we can see more than the odd &amp; even range that I did earlier.However, since this method stores n length values to dp, the space complexity is O(n).3. Optimal Solution  Inplace shifting  TC : O(n)  SC: O(1)class Solution:    def rob(self, nums: List[int]) -&gt; int:        # [...,  prev, max, curr, ...]        prev_house = 0        max_house = 0                if len(nums) == 1:            return nums[0]        for curr in nums:            temp = max(max_house, prev_house + curr)            prev_house = max_house  # we know, num increment by 1, as well as prev_house            max_house = temp    # change current house as max_house        return max_houseThis is a more efficient way of dealing with the space complexity. There are no other storing variables, such as a stack. It just calculates the current maximum value while it is iterating over all elements.The Key for this method is resetting prev and max points.Additional materials      House Robber II  (The new circumstance is houses are in circle formation)  üí°2 cases to be considered  "
  },
  
  {
    "title": "First Post",
    "url": "/posts/first-post/",
    "categories": "etc..",
    "tags": "etc",
    "date": "2024-07-25 15:29:28 -0400",
    





    
    "snippet": "Hi,Welcome to my github blog.I will mainly upload content related to programming notes.  Leetcode Solutions          Meeting      Self-study        Academic Note          Data Structure &amp; Algor...",
    "content": "Hi,Welcome to my github blog.I will mainly upload content related to programming notes.  Leetcode Solutions          Meeting      Self-study        Academic Note          Data Structure &amp; Algorithm, Design Pattern, Machine Learning      "
  }
  
]

