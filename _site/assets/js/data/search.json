[
  
  {
    "title": "139. Word Break",
    "url": "/posts/139.-word-break/",
    "categories": "programming, leetcode",
    "tags": "tag",
    "date": "2024-07-30 14:58:50 -0400",
    





    
    "snippet": "url: https://leetcode.com/problems/word-break/description/Example  Input: s = ‚Äúleetcode‚Äù, wordDict = [‚Äúleet‚Äù,‚Äùcode‚Äù]Output: true Explanation: Return true because ‚Äúleetcode‚Äù can be segmented as ‚Äúlee...",
    "content": "url: https://leetcode.com/problems/word-break/description/Example  Input: s = ‚Äúleetcode‚Äù, wordDict = [‚Äúleet‚Äù,‚Äùcode‚Äù]Output: true Explanation: Return true because ‚Äúleetcode‚Äù can be segmented as ‚Äúleet code‚Äù.üí° Note that you are allowed to reuse a dictionary word.üíª CodeApproach : We only need to iterate s once, and wordDict should be checked at the same time.Things to consider :  Strings in the wordDict can be used multiple times.  Unique strings.  Matching strings in s cannot be overlapped.1. Dynamic Programming  TC : O(n * m)          n : length of s      m : max length of wordDict        SC: O(n) - dpclass Solution:    def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:        # All the strings of wordDict are unique.        wordSet = set(wordDict)        # checking strings connected w/o overlapping        # true .... true -&gt; it makes a single string that in twordDict        dp = [False] * (len(s) + 1)        dp[0] = True         for i in range(1, len(s) + 1):            for j in range(i):                # dp[j] picks up where we left off last time                # until it matches                if dp[j] and s[j:i] in wordSet:                     dp[i] = True                    break                # return if the last index is true        return dp[len(s)]Using DP to track whether the current position of s is the part of the strings in wordDict allows an intuitive result because of the dp table. Check below the short version of dp table in processing:                      l      e      e      t      c      o      d      e        -------------------------------------------------------------------        dp = [True, False, False, False, False, False, False, False, False]        dp = [True, False, False, False, True, False, False, False, False]        dp = [True, False, False, False, True, False, False, False, True]            =&gt; dp[len(s)] = True            It checks only if the last index is True2. DFS  TC : O(n^2)  SC: O(n)    class Solution:  def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:      visited = {}      wordSet = set(wordDict)      def dfs(s, wordSet, visited):          if s in visited:              return visited[s]          if s in wordSet:              return True          for i in range(1, len(s)):              prefix = s[:i]              if prefix in wordSet and dfs(s[i:], wordSet, visited):                  visited[s] = True                  return True                  visited[s] = False          return False      return dfs(s, wordSet, visited)        The code processing:      Initial call: dfs(\"leetcode\")      Check prefix \"l\", not in wordSet.      Check prefix \"le\", not in wordSet.      Check prefix \"lee\", not in wordSet.      Check prefix \"leet\", in wordSet.          Recursive call: dfs(\"code\")              Check prefix \"c\", not in wordSet.              Check prefix \"co\", not in wordSet              Check prefix \"cod\", not in wordSet              Check prefix \"code\", in wordSet                  Memoize and return True for \"code\".          Memoize and return True for \"leetcode\"      "
  },
  
  {
    "title": "198. House Robber",
    "url": "/posts/198.-house-robber/",
    "categories": "programming, leetcode",
    "tags": "DP, Dynamic Programming, House Robber",
    "date": "2024-07-26 13:35:07 -0400",
    





    
    "snippet": "url: https://leetcode.com/problems/house-robber/description/Example  Input: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). ...",
    "content": "url: https://leetcode.com/problems/house-robber/description/Example  Input: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.üíª Code1. Brute Force (does not pass all cases)  TC : O(n)  SC: O(n) - stackclass Solution:    def rob(self, nums: List[int]) -&gt; int:        n = len(nums)           res = 0        odd_house = []        even_house = [nums[0]]        for i in range(1, n):            if i % 2 == 1:\t# odd houses                odd_house.append(nums[i])            else:                even_house.append(nums[i])                    res = max(sum(odd_house), sum(even_house))          return res My initial approach to the problem is checking houses to see whether they are odd or even.However, this method can‚Äôt handle edge cases. For example, there is a possibility that the sum of indices 0 and 3 can make a maximum amount.2. Dynamic Programming  TC : O(n)  SC: O(n) - DPclass Solution:    def rob(self, nums: List[int]) -&gt; int:        n = len(nums)        if n == 1:            return nums[0]        dp = [0] * n        dp[0] = nums[0]        dp[1] = max(nums[0], nums[1])        for i in range(2, n):            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])        return dp[-1]Using Dynamic Programming cut the edges where I had a problem. This compares with the current(i - 2) + current(i) and current(i - 1), and the current the maximum value is stored at the current position in dp.By changing the current value, we can see more than the odd &amp; even range that I did earlier.However, since this method stores n length values to dp, the space complexity is O(n).3. Optimal Solution  Inplace shifting  TC : O(n)  SC: O(1)class Solution:    def rob(self, nums: List[int]) -&gt; int:        # [...,  prev, max, curr, ...]        prev_house = 0        max_house = 0                if len(nums) == 1:            return nums[0]        for curr in nums:            temp = max(max_house, prev_house + curr)            prev_house = max_house  # we know, num increment by 1, as well as prev_house            max_house = temp    # change current house as max_house        return max_houseThis is a more efficient way of dealing with the space complexity. There are no other storing variables, such as a stack. It just calculates the current maximum value while it is iterating over all elements.The Key for this method is resetting prev and max points.Additional materials      House Robber II  (The new circumstance is houses are in circle formation)  üí°2 cases to be considered  "
  },
  
  {
    "title": "First Post",
    "url": "/posts/first-post/",
    "categories": "etc..",
    "tags": "etc",
    "date": "2024-07-25 15:29:28 -0400",
    





    
    "snippet": "Hi,Welcome to my github blog.I will mainly upload content related to programming notes.  Leetcode Solutions          Meeting      Self-study        Academic Note          Data Structure &amp; Algor...",
    "content": "Hi,Welcome to my github blog.I will mainly upload content related to programming notes.  Leetcode Solutions          Meeting      Self-study        Academic Note          Data Structure &amp; Algorithm, Design Pattern, Machine Learning      "
  }
  
]

